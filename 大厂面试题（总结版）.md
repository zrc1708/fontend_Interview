## js的基础类型与引用类型
- 基本数据类型：null，undefined，boolean，number，string，symbol
- 引用数据类型：对象类型Object type，比如：Object 、Array 、Function 、Data

## 如何对引用类型进行深拷贝（stringfy加上json.parse）其他的方式
```js
let a = {name:'zhangsan'}
let b = JSON.parse(JSON.stringify(a))
```
这种方法有局限性
+ 会忽略 undefined
+ 会忽略 symbol
+ 不能序列化函数
+ 不能解决循环引用的对象

## cookie和session
|  特性   | cookie  | localStorage | sessionStorage |
|  ----  | ----  | ---- | ---- |
| 数据生命周期  | 一般由服务器生成，可以设置过期时间 |除非被清理，否则一直存在 |页面关闭就清理 |
| 数据存储大小  | 4K | 5M | 5M |
| 与服务端通信  | 每次都会携带在 header 中，对于请求性能影响 | 不参与 | 不参与 |
## CSRF  
+ CSRF，即跨站请求伪造（英语：Cross-site request forgery）
+ 攻击者盗用了你的身份，以你的名义发送恶意请求。CSRF能够做的事情包括：以你名义发送邮件，发消息，盗取你的账号，甚至于购买商品，虚拟货币转账......造成的问题包括：个人隐私泄露以及财产安全。
+ 要完成一次CSRF攻击，受害者必须依次完成两个步骤：  
　　1.登录受信任网站A，并在本地生成Cookie。  
　　2.在不登出A的情况下，访问危险网站B。  
+ 例子：银行网站A，它以GET请求来完成银行转账的操作，如：http://www.mybank.com/Transfer.php?toBankId=11&money=1000
+ 危险网站B，它里面有一段HTML的代码如下：
```html
<img src=http://www.mybank.com/Transfer.php?toBankId=11&money=1000>
```
+ 首先，你登录了银行网站A，然后访问危险网站B，噢，这时你会发现你的银行账户少了1000块
+ 为什么会这样呢？原因是银行网站A违反了HTTP规范，使用GET请求更新资源。在访问危险网站B的之前，你已经登录了银行网站A，而B中的<img>以GET的方式请求第三方资源（这里的第三方就是指银行网站了，原本这是一个合法的请求，但这里被不法分子利用了），所以你的浏览器会带上你的银行网站A的Cookie发出Get请求，去获取资源“http://www.mybank.com/Transfer.php?toBankId=11&money=1000” ，结果银行网站服务器收到请求后，认为这是一个更新资源操作（转账操作），所以就立刻进行转账操作
+ 如何防御？
    - Get 请求不对数据进行修改
    - 不让第三方网站访问到用户 Cookie
    - 阻止第三方网站请求接口
    - 请求时附带验证信息，比如验证码或者 token

## XSS
+ XSS ,即跨站脚本攻击，通过修改 HTML 节点或者执行 JS 代码来攻击网站
例如通过 URL 获取某些参数
```html
<!-- http://www.domain.com?name=<script>alert(1)</script> -->
<div>{{name}}</div>
``` 
+ 网页把用户通过GET发送过来的表单数据，未经处理直接写入返回的html流，这就是XSS漏洞所在
+ 如何防御？
最普遍的做法是转义输入输出的内容，对于引号，尖括号，斜杠进行转义

## function有变量提升吗？（函数提升）
```js
fn()    //123
console.log(fn)     //fn(){console.log('123')}
function fn(){
    console.log('123')
}
var fn = '456'
fn()    //456
```
```js
console.log(foo1); // [Function: foo1]
foo1(); // foo1
console.log(foo2); // undefined
foo2(); // TypeError: foo2 is not a function
function foo1 () {
    console.log("foo1");
};
var foo2 = function () {
    console.log("foo2");
};
```
- 函数提升只会提升函数声明，而不会提升函数表达式
## 跨域
+ JSONP
    + JSONP 的原理很简单，就是利用 \<script> 标签没有跨域限制的漏洞。
    + 通过 \<script> 标签指向一个需要访问的地址并提供一个回调函数来接收数据当需要通讯时。
    ```JS
    <script src="http://domain/api?param1=a&param2=b&callback=jsonp"></script>
    <script>
        function jsonp(data) {
            console.log(data)
        }
    </script>
    ```
+ CORS
    + 使用 CORS 的方式，CORS 是一个 W3C 标准，全称是"跨域资源共享"。
    + CORS 需要浏览器和服务器同时支持。目前，所有主流浏览器都支持该功能（IE 8 和 9 需要通过 XDomainRequest 来实现），因此我们只需要在服务器端配置就行。浏览器将 CORS 请求分成两类：简单请求和非简单请求。
    + 对于简单请求，浏览器直接发出 CORS 请求。具体来说，就是会在头信息之中，增加一个 Origin 字段。Origin 字段用来说明本次请求来自哪个源。服务器根据这个值，决定是否同意这次请求。对于如果 Origin 指定的源，不在许可范围内，服务器会返回一个正常的 HTTP 回应。浏览器发现，这个回应的头信息没有包含 Access-Control-Allow-Origin 字段，就知道出错了，从而抛出一个错误，ajax 不会收到响应信息。如果成功的话会包含一些以 Access-Control- 开头的字段。
+ document.domain
    + 该方式只能用于二级域名相同的情况下，比如 a.test.com 和 b.test.com 适用于该方式。
    + 只需要给页面添加 document.domain = 'test.com' 表示二级域名都相同就可以实现跨域
+ nginx反向代理跨域
## let const var讲一下
- var声明的变量会挂载在window上，而let和const声明的变量不会
- var声明变量存在变量提升，let和const不存在变量提升
- let和const声明形成块作用域
- 同一作用域下let和const不能声明同名变量，而var可以
- const
    - 1、一旦声明必须赋值,不能使用null占位。
    - 2、声明后不能再修改
    - 3、如果声明的是复合类型数据，可以修改其属性
## http 1.0 1.1 2.0 s*
### HTTP1.0和HTTP1.1的一些区别  
- （1）连接方面的区别，http1.1 默认使用持久连接，而 http1.0 默认使用非持久连接。http1.1 通过使用持久连接来使多个 http 请求复用同一个 TCP 连接，以此来避免使用非持久连接时每次需要建立连接的时延。
- （2）资源请求方面的区别，在 http1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，http1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是 206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。
- （3）缓存方面的区别，在 http1.0 中主要使用 header 里的 If-Modified-Since,Expires 来做为缓存判断的标准，http1.1 则引入了更多的缓存控制策略例如 Etag、If-Unmodified-Since、If-Match、If-None-Match 等更多可供选择的缓存头来控制缓存策略。
- （4）http1.1 中还新增了 host 字段，用来指定服务器的域名。http1.0 中认为每台服务器都绑定一个唯一的 IP 地址，因此，请求消息中的 URL 并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机，并且它们共享一个IP地址。因此有了 host 字段，就可以将请求发往同一台服务器上的不同网站。
- （5）http1.1 相对于 http1.0 还新增了很多方法，如 PUT、HEAD、OPTIONS 等。
### HTTP2与HTTP1.1的区别
- 1.HTTP2使用的是二进制传送，HTTP1.X是文本（字符串）传送。  
大家都知道HTTP1.X使用的是明文的文本传送，而HTTP2使用的是二进制传送，二进制传送的单位是帧和流。帧组成了流，同时流还有流ID标示，通过流ID就牵扯出了第二个区别
- 2.HTTP2支持多路复用  
因为有流ID，所以通过同一个http请求实现多个http请求传输变成了可能，可以通过流ID来标示究竟是哪个流从而定位到是哪个http请求
- 3.HTTP2头部压缩  
HTTP2通过gzip和compress压缩头部然后再发送，同时客户端和服务器端同时维护一张头信息表，所有字段都记录在这张表中，这样后面每次传输只需要传输表里面的索引Id就行，通过索引ID就可以知道表头的值了
- 4.HTTP2支持服务器推送  
HTTP2支持在客户端未经请求许可的情况下，主动向客户端推送内容  
HTTP/2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送。使用服务器推送，提前给客户端推送必要的资源，这样就可以相对减少一些延迟时间。
### HTTPS与HTTP的一些区别
- HTTPS协议需要到CA申请证书，一般免费证书很少，需要交费。
- HTTP协议运行在TCP之上，所有传输的内容都是明文，HTTPS运行在SSL/TLS之上，SSL/TLS运行在TCP之上，所有传输的内容都经过加密的。
- HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。
- HTTPS可以有效的防止运营商劫持，解决了防劫持的一个大问题。
## http状态码*
| |类别|原因短语|
|--|--|--|
|1XX|Informational（信息性状态码）|接收的请求正在处理|
|2XX|Success（成功状态码）|请求正常处理完毕|
|3XX|Redirection（重定向状态码）|需要进行附加操作以完成请求|
|4XX|Client Error（客户端错误状态码）|服务器无法处理请求|
|5XX|Server Error（服务器错误状态码）|服务器处理请求出错|
+ 200 OK  
表示从客户端发来的请求在服务器端被正常处理了。
+ 204 No Content  
该状态码代表服务器接收的请求已成功处理，但在返回的响应报文中不含实体的主体部分。  
比如，当从浏览器发出请求处理后，返回 204 响应，那么浏览器显示的页面不发生更新。  
一般在只需要从客户端往服务器发送信息，而对客户端不需要发送新信息内容的情况下使用。
+ 206 Partial Content  
该状态码表示客户端进行了范围请求，而服务器成功执行了这部分的 GET 请求。  
响应报文中包含由 Content-Range 指定范围的实体内容。

+ 301 Moved Permanently  
永久性重定向。该状态码表示请求的资源已被分配了新的 URI，以后应使用资源现在所指的 URI。  
也就是说，如果已经把资源对应的 URI保存为书签了，这时应该按 Location 首部字段提示的 URI 重新保存。
+ 302 Found  
临时性重定向。该状态码表示请求的资源已被分配了新的 URI，希望用户（本次）能使用新的 URI 访问。  
和 301 Moved Permanently 状态码相似，但 302 状态码代表的资源不是被永久移动，只是临时性质的。  
换句话说，已移动的资源对应的URI 将来还有可能发生改变。  
比如，用户把 URI 保存成书签，但不会像301 状态码出现时那样去更新书签，而是仍旧保留返回 302 状态码的页面对应的 URI。
+ 303 See Other  
该状态码表示由于请求对应的资源存在着另一个 URI，应使用 GET方法定向获取请求的资源。
+ 304 Not Modified  
该状态码表示客户端发送附带条件（是指采用GET方法的请求报文中包含if-Match、If-Modified-Since、If-None-Match、If-Range、If-Unmodified-Since中任一首部）的请求时，服务器端允许请求访问资源，但因发生请求未满足条件的情况后，直接返回 304 Not Modified（服务器端资源未改变，可直接使用客户端未过期的缓存）。
+ 307 Temporary Redirect  
临时重定向。该状态码与 302 Found 有着相同的含义。尽管 302 标准禁止 POST 变换成 GET，但实际使用时大家并不遵守。
+ 400 Bad Request  
该状态码表示请求报文中存在语法错误。当错误发生时，需修改请求的内容后再次发送请求。
+ 401 Unauthorized  
该状态码表示发送的请求需要有通过 HTTP 认证（BASIC 认证、DIGEST 认证）的认证信息。  
另外若之前已进行过 1 次请求，则表示用户认证失败。
+ 403 Forbidden  
该状态码表明对请求资源的访问被服务器拒绝了。服务器端没有必要给出拒绝的详细理由，  
但如果想作说明的话，可以在实体的主体部分对原因进行描述，这样就能让用户看到了。
+ 404 Not Found  
该状态码表明服务器上无法找到请求的资源。除此之外，也可以在服务器端拒绝请求且不想说明理由时使用。
+ 500 Internal Server Error  
该状态码表明服务器端在执行请求时发生了错误。也有可能是 Web应用存在的 bug 或某些临时的故障。
+ 503 Service Unavailable  
该状态码表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。
## 浏览器渲染页面过程
## get和post的区别
## call apply bind*
## input标签的type值列举
## localstorage和sessionstorage的区别*
## 原型链讲一下，__proto__ 和 prototype 的区别
## 输入一个网址的全过程
## 什么是原型和原型链
## 什么是作用域链
## 什么是块级作用域
## es6的新特性*
## 三次握手四次挥手
## BFC
## 防抖和节流
## 浏览器重绘和重排
## new 的过程中发生了啥
## Promise.all，原理，手写
## vue双向绑定