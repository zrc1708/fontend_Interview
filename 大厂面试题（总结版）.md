## js的基础类型与引用类型
- 基本数据类型：null，undefined，boolean，number，string，symbol
- 引用数据类型：对象类型Object type，比如：Object 、Array 、Function 、Data

## 如何对引用类型进行深拷贝（stringfy加上json.parse）其他的方式
```js
let a = {name:'zhangsan'}
let b = JSON.parse(JSON.stringify(a))
```
这种方法有局限性
+ 会忽略 undefined
+ 会忽略 symbol
+ 不能序列化函数
+ 不能解决循环引用的对象

## cookie和session
|  特性   | cookie  | localStorage | sessionStorage |
|  ----  | ----  | ---- | ---- |
| 数据生命周期  | 一般由服务器生成，可以设置过期时间 |除非被清理，否则一直存在 |页面关闭就清理 |
| 数据存储大小  | 4K | 5M | 5M |
| 与服务端通信  | 每次都会携带在 header 中，对于请求性能影响 | 不参与 | 不参与 |
## CSRF  
+ CSRF，即跨站请求伪造（英语：Cross-site request forgery）
+ 攻击者盗用了你的身份，以你的名义发送恶意请求。CSRF能够做的事情包括：以你名义发送邮件，发消息，盗取你的账号，甚至于购买商品，虚拟货币转账......造成的问题包括：个人隐私泄露以及财产安全。
+ 要完成一次CSRF攻击，受害者必须依次完成两个步骤：  
　　1.登录受信任网站A，并在本地生成Cookie。  
　　2.在不登出A的情况下，访问危险网站B。  
+ 例子：银行网站A，它以GET请求来完成银行转账的操作，如：http://www.mybank.com/Transfer.php?toBankId=11&money=1000
+ 危险网站B，它里面有一段HTML的代码如下：
```html
<img src=http://www.mybank.com/Transfer.php?toBankId=11&money=1000>
```
+ 首先，你登录了银行网站A，然后访问危险网站B，噢，这时你会发现你的银行账户少了1000块
+ 为什么会这样呢？原因是银行网站A违反了HTTP规范，使用GET请求更新资源。在访问危险网站B的之前，你已经登录了银行网站A，而B中的<img>以GET的方式请求第三方资源（这里的第三方就是指银行网站了，原本这是一个合法的请求，但这里被不法分子利用了），所以你的浏览器会带上你的银行网站A的Cookie发出Get请求，去获取资源“http://www.mybank.com/Transfer.php?toBankId=11&money=1000” ，结果银行网站服务器收到请求后，认为这是一个更新资源操作（转账操作），所以就立刻进行转账操作
+ 如何防御？
    - Get 请求不对数据进行修改
    - 不让第三方网站访问到用户 Cookie
    - 阻止第三方网站请求接口
    - 请求时附带验证信息，比如验证码或者 token

## XSS
+ XSS ,即跨站脚本攻击，通过修改 HTML 节点或者执行 JS 代码来攻击网站
例如通过 URL 获取某些参数
```html
<!-- http://www.domain.com?name=<script>alert(1)</script> -->
<div>{{name}}</div>
``` 
+ 网页把用户通过GET发送过来的表单数据，未经处理直接写入返回的html流，这就是XSS漏洞所在
+ 如何防御？
最普遍的做法是转义输入输出的内容，对于引号，尖括号，斜杠进行转义

## function有变量提升吗？（函数提升）
```js
fn()    //123
console.log(fn)     //fn(){console.log('123')}
function fn(){
    console.log('123')
}
var fn = '456'
fn()    //456
```
```js
console.log(foo1); // [Function: foo1]
foo1(); // foo1
console.log(foo2); // undefined
foo2(); // TypeError: foo2 is not a function
function foo1 () {
    console.log("foo1");
};
var foo2 = function () {
    console.log("foo2");
};
```
- 函数提升只会提升函数声明，而不会提升函数表达式
## 跨域
+ JSONP
    + JSONP 的原理很简单，就是利用 \<script> 标签没有跨域限制的漏洞。
    + 通过 \<script> 标签指向一个需要访问的地址并提供一个回调函数来接收数据当需要通讯时。
    ```JS
    <script src="http://domain/api?param1=a&param2=b&callback=jsonp"></script>
    <script>
        function jsonp(data) {
            console.log(data)
        }
    </script>
    ```
+ CORS
    + 使用 CORS 的方式，CORS 是一个 W3C 标准，全称是"跨域资源共享"。
    + CORS 需要浏览器和服务器同时支持。目前，所有主流浏览器都支持该功能（IE 8 和 9 需要通过 XDomainRequest 来实现），因此我们只需要在服务器端配置就行。浏览器将 CORS 请求分成两类：简单请求和非简单请求。
    + 对于简单请求，浏览器直接发出 CORS 请求。具体来说，就是会在头信息之中，增加一个 Origin 字段。Origin 字段用来说明本次请求来自哪个源。服务器根据这个值，决定是否同意这次请求。对于如果 Origin 指定的源，不在许可范围内，服务器会返回一个正常的 HTTP 回应。浏览器发现，这个回应的头信息没有包含 Access-Control-Allow-Origin 字段，就知道出错了，从而抛出一个错误，ajax 不会收到响应信息。如果成功的话会包含一些以 Access-Control- 开头的字段。
+ document.domain
    + 该方式只能用于二级域名相同的情况下，比如 a.test.com 和 b.test.com 适用于该方式。
    + 只需要给页面添加 document.domain = 'test.com' 表示二级域名都相同就可以实现跨域
+ nginx反向代理跨域
## let const var讲一下
- var声明的变量会挂载在window上，而let和const声明的变量不会
- var声明变量存在变量提升，let和const不存在变量提升
- let和const声明形成块作用域
- 同一作用域下let和const不能声明同名变量，而var可以
- const
    - 1、一旦声明必须赋值,不能使用null占位。
    - 2、声明后不能再修改
    - 3、如果声明的是复合类型数据，可以修改其属性
## http 1.0 1.1 2.0 s*
### HTTP1.0和HTTP1.1的一些区别  
- （1）连接方面的区别，http1.1 默认使用持久连接，而 http1.0 默认使用非持久连接。http1.1 通过使用持久连接来使多个 http 请求复用同一个 TCP 连接，以此来避免使用非持久连接时每次需要建立连接的时延。
- （2）资源请求方面的区别，在 http1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，http1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是 206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。
- （3）缓存方面的区别，在 http1.0 中主要使用 header 里的 If-Modified-Since,Expires 来做为缓存判断的标准，http1.1 则引入了更多的缓存控制策略例如 Etag、If-Unmodified-Since、If-Match、If-None-Match 等更多可供选择的缓存头来控制缓存策略。
- （4）http1.1 中还新增了 host 字段，用来指定服务器的域名。http1.0 中认为每台服务器都绑定一个唯一的 IP 地址，因此，请求消息中的 URL 并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机，并且它们共享一个IP地址。因此有了 host 字段，就可以将请求发往同一台服务器上的不同网站。
- （5）http1.1 相对于 http1.0 还新增了很多方法，如 PUT、HEAD、OPTIONS 等。
### HTTP2与HTTP1.1的区别
- 1.HTTP2使用的是二进制传送，HTTP1.X是文本（字符串）传送。  
大家都知道HTTP1.X使用的是明文的文本传送，而HTTP2使用的是二进制传送，二进制传送的单位是帧和流。帧组成了流，同时流还有流ID标示，通过流ID就牵扯出了第二个区别
- 2.HTTP2支持多路复用  
因为有流ID，所以通过同一个http请求实现多个http请求传输变成了可能，可以通过流ID来标示究竟是哪个流从而定位到是哪个http请求
- 3.HTTP2头部压缩  
HTTP2通过gzip和compress压缩头部然后再发送，同时客户端和服务器端同时维护一张头信息表，所有字段都记录在这张表中，这样后面每次传输只需要传输表里面的索引Id就行，通过索引ID就可以知道表头的值了
- 4.HTTP2支持服务器推送  
HTTP2支持在客户端未经请求许可的情况下，主动向客户端推送内容  
HTTP/2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送。使用服务器推送，提前给客户端推送必要的资源，这样就可以相对减少一些延迟时间。
### HTTPS与HTTP的一些区别
- HTTPS协议需要到CA申请证书，一般免费证书很少，需要交费。
- HTTP协议运行在TCP之上，所有传输的内容都是明文，HTTPS运行在SSL/TLS之上，SSL/TLS运行在TCP之上，所有传输的内容都经过加密的。
- HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。
- HTTPS可以有效的防止运营商劫持，解决了防劫持的一个大问题。
## http状态码*
## 浏览器渲染页面过程
## get和post的区别
## call apply bind*
## input标签的type值列举
## localstorage和sessionstorage的区别*
## 原型链讲一下，__proto__ 和 prototype 的区别
## 输入一个网址的全过程
## 什么是原型和原型链
## 什么是作用域链
## 什么是块级作用域
## es6的新特性*
## 三次握手四次挥手
## BFC
## 防抖和节流
## 浏览器重绘和重排
## new 的过程中发生了啥
## Promise.all，原理，手写
## vue双向绑定